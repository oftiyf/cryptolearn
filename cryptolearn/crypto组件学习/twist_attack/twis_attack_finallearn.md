## 原理
- 前置知识，群，椭圆曲线，离散对数等等，这里不赘述了 ECDSA SECP256k1
先一句话概括，方便复习：其内核就是一个与小子群攻击，然后再暴力枚举有共同之处。但是在一般的安全素数p内部（根据拉格朗日定理，这意味着该群没有非平凡的子群）不能直接使用，所以还是用这个思想进行钓鱼（就是被攻击者没有检查我们攻击者提供的“公钥”是否在群内，然后ECDH交换公钥的时候导致攻击者构造的小子群内部实现暴露私钥，实际上也是要多次构造，然后用CRT去复原最好最快）
```p = 115792089237316195423570985008687907853269984665640564039457584007908834671663
E = EllipticCurve(GF(p), [0,2])
Grp = E.abelian_group()
g = Grp.gens()[0]
numElements = g.order()
print( "{0} = {1}".format(numElements, factor(numElements)) )```
上面生成一个在曲线上面的阿贝尔群然后再生成它的生成元
OK，这里直接拿以太坊和比特币用的曲线当做例子，它的曲线是
$y^2 = x^3 + 7$
然后我这边构造了一个恶意子群
$y^2 = x^3 + 2$
它有的特点是子群内部有一个小素数分解的阶3319（也不能说是小的，应该说是合适的，方便CRT的时候复原），就是上面这个代码
输出
```38597363079105398474523661669562635951234135017402074565436668291433169282997 = 3 * 13^2 * 3319 * 22639 * 1013176677300131846900870239606035638738100997248092069256697437031```
然后构造我们的恶意点
```n1 = 3
n2 = 13*13
n3 = 3319
n4 = 22639
n5 = 
1013176677300131846900870239606035638738100997248092069256697437031
x = crt([0,0,1,0,0], [n1,n2,n3,n4,n5])
print(x)
P = x*g
print(P)
print(P.order())
Q = b * P
```
然后在让被攻击者去签名一下
```cipherText = encrypt(Q, "Hello")```
攻击者得到签名信息后就可以直接进行爆破了在小子群下的某个特征了(因为在小子群内部，所以说爆破就很简单了)
```y = 0
for i in range(1, 3319):
  if key_does_decrypt(i*P, cipherText):
    y = i
```
但是得到的i并不一定就是私钥，因为在小子群内部，所以我要多次制造恶意的这种签名（用多个不同的恶意曲线）
```
E1: y^2 = x^3 + 1
E2: y^2 = x^3 + 2
E3: y^2 = x^3 + 3
E4: y^2 = x^3 + 4
E6: y^2 = x^3 + 6
```
下面是对应的分解
```
E1: 20412485227
E2: 3319, 22639
E3: 109903, 12977017, 383229727
E4: 18979
E6: 10903, 5290657, 10833080827, 22921299619447
```
然后在把找到的内容进行复原，我们直接CRT复原就行
```
x11 = b mod 20412485227
x21 = b mod 3319
x22 = b mod 22639
x31 = b mod 109903
x32 = b mod 12977017
x33 = b mod 383229727
x41 = b mod 18979
x61 = b mod 10903
x62 = b mod 5290657
x63 = b mod 10833080827
x64 = b mod 22921299619447
```