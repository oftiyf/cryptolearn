# 简介
- 写在前面，真实协议要求随机数确认（就是防止攻击，但是这个过程和zkp关系不大，所以我就没有在代码实现里面去写了，实际上用基础rsa也行，但是感觉和zkp关系不大）
- 选自 https://eprint.iacr.org/2023/1879.pdf
## 哪些地方的暴露会导致协议丧失零知识性(安全分析)
1. **服务器的信任问题**：
  注意，在协议的两个版本中，如果服务器被破坏，它可以对哈希值进行暴力破解。实际上，如果 \( P_i \) 在第一次运行中是数据所有者，那么服务器 \( S \) 将学习到所有 \( j \in P \setminus \{P_i\} \) 的 \( h(x_j, y_j) \)（或在阈值协议中已知 \( (s_0, t_0) \)）。如果 \( P_u \neq P_i \) 在第二次运行中是数据所有者，那么 \( S \) 也会学习到 \( h(x_i, y_j) \)（或在阈值协议中学习到 \( h(f(x_i), g(x_i)) \)）。我们可以通过让参与者使用某种组密钥交换协议达成一致，选择一个随机数 \( R \)，并在消息 \( R \cdot m \) 而不是 \( m \) 上运行协议，从而防止这种情况的发生。除了 \( S \) 之外的其他参与者无法执行此攻击，因为每条消息都是通过安全通道发送的。
另外，如果 \( P_1 \) 发送 \( h(m_1 + x_1, m_2 + y_1) \)（或在阈值情况下发送 \( h(m_1 + f(x_1) \cdot \ell_1, m_2 + g(x_1) \cdot \ell_1) \)，其中 \( (m_1, m_2) \in GF(p)^2 \），则可以将明文空间的大小加倍。
2. **随机数生成的不安全性**：
   - 如果生成的随机数（如 \( r_i \)）不够随机或被预测，攻击者可能会利用这些信息来恢复参与者的秘密值，从而导致数据泄露。

3. **参与者之间的协作问题**：
   - 如果参与者之间没有有效的沟通机制，或者在协议执行过程中有任意参与者未按要求执行，可能会导致不一致的状态，从而使得某些秘密信息被间接泄露。

4. **重放攻击**：
   - 如果没有适当的消息认证机制，攻击者可能会重放先前的有效消息，试图诱导服务器或其他参与者相信某些操作是有效的，从而可能导致信息泄露。

5. **对安全通道的依赖**：
   - 协议假设所有消息都是在安全通道中传输的。如果传输通道被攻击，攻击者可能会截获或篡改消息，导致秘密信息的泄露。

6. **参与者的秘密值管理不当**：
   - 每个参与者都有其秘密值。如果参与者的秘密值管理不当（例如，泄露给不可信的第三方），可能会导致整个协议的安全性受到威胁。

7. **参数选择不当**：
   - 使用的曲线或参数如果选择不当，可能会导致基础密码学假设的破裂，从而使得协议中的哈希函数不再安全，攻击者可能会找到碰撞或逆向哈希。

以上这些情况都可能导致协议的安全性受损，进而影响到零知识证明的有效性。因此，确保每个环节的安全性和参与者的信任是至关重要的。
## 基础协议步骤
好的，以下是修正后的翻译，确保 LaTeX 内联表达式格式正确：

### 多方阈值匿名协议
好的，以下是修正后的翻译，确保 LaTeX 内联表达式格式正确：

### 多方阈值匿名协议

1. 首先，服务器 \( S \) 生成两个秘密值 \( s_0 \) 和 \( t_0 \)，并使用 Shamir 的秘密共享方案将它们分发给参与者 \( P \) 中的成员。\( S \) 使用两个不同的多项式 \( f(x) = s_0 + \sum_{i=1}^{k-1} a_i x^i \) 和 \( g(x) = t_0 + \sum_{i=1}^{k-1} b_i x^i \)。令 \( x_1, \ldots, x_n \in GF(p) \) 为各个 \( P_i \) 生成的秘密随机元素。

2. 在接收到来自 \( P_i \) 的 \( \text{Enc}_{K_{\text{pub}}^i}(x_i) \) 后，\( S \) 将 \( f(\text{Enc}_{K_{\text{pub}}^i}(x_i)) = \text{Enc}_{K_{\text{pub}}^i}(f(x_i)) \) 和 \( g(\text{Enc}_{K_{\text{pub}}^i}(x_i)) = \text{Enc}_{K_{\text{pub}}^i}(g(x_i)) \) 发送给 \( P_i \)，其中 \( K_{\text{pub}}^i \) 是 \( P_i \) 的公钥。

3. 每对 \( (P_i, P_{i+1}) \) 与 \( S \) 共享商 \( \frac{x_{i+1}}{x_i} \)，使用下面描述的乘法协议。

4. 在接收到来自 \( P_1 \) 的匿名请求后，\( S \) 随机选择一个 \( k \) 元素子集 \( Q \subseteq P \)。不失一般性，假设现在 \( Q = \{P_1, \ldots, P_k\} \)。此外，\( S \) 生成 \( k \) 个随机值 \( r_1, r_2, \ldots, r_k \) 并将 \( r_i \) 发送给 \( P_i \in Q \)。

5. 对于每个参与者 \( P_i \in Q \)，\( S \) 计算 \( \ell_i = \prod_{j=1, j \neq i}^{k} \frac{x_j}{x_j - x_i} \) 并将 \( \ell_i \) 发送给 \( P_i \)。

6. 收到来自 S 的 r1 和 ℓ1 后，P1 计算 h1 = h(m + f(x1)· ℓ1, g(x1)· ℓ1)，并将 h1|EncK_pub_S(r1) 发送给 S，其中 K_pub_S 是 S 的公钥。

7. 对于所有 i = 2, . . . , k，当收到来自 S 的 ri 时，Pi 计算 hi = h(f(xi) · ℓi, g(xi) · ℓi)，并将 hi|EncK_pub_S(ri) 发送给 S。
8. 当 S 收到来自 Pi 的 hi|EncK_pub_S(ri)（对于所有 i = 1, . . . , k）时，S 存储 

\[
Y_{k} = \prod_{i=1}^{k} h_i = a^{m + \sum_{i=1}^{k} f(x_i) \cdot \ell_i} \cdot b^{\sum_{i=1}^{k} g(x_i) \cdot \ell_i} = a^{m+s_0} \cdot b^{t_0}
\]

如果随机值 r1, r2, . . . , rk 与 S 在第一步发送的值相同。否则，S 输出错误信息。
## 内生的交换协议(针对步骤5当中要安全得到其中的安全参数，并且不透露知识)
### 双方乘法协议

1. **Multiply(x, y)** 接受来自两个不同参与者的两个输入：\( x \) 来自 \( P_1 \)，\( y \) 来自 \( P_2 \)。
2. \( P_1 \) 生成一个随机数 \( r_1 \) 并将 \( r_1 \cdot x \) 发送给 \( P_2 \)，然后 \( P_2 \) 生成一个随机数 \( r_2 \)，计算 \( r_1 \cdot x \cdot r_2 \cdot y \) 并将结果发送给服务器。
3. 服务器还生成一个随机值 \( r_S \)，计算 \( r_S \cdot r_1 \cdot x \cdot r_2 \cdot y \) 并将其发送回 \( P_1 \)。
4. \( P_1 \) 计算 \( r^{-1}_1 \cdot r_S \cdot r_1 \cdot x \cdot r_2 \cdot y = r_S \cdot x \cdot r_2 \cdot y \) 并将结果发送给 \( P_2 \)。
5. \( P_2 \) 计算 \( r^{-1}_2 \cdot r_S \cdot x \cdot r_2 \cdot y = r_S \cdot x \cdot y \) 并将结果发送给服务器。
6. 服务器计算 \( r^{-1}_S \cdot r_S \cdot x \cdot y = x \cdot y \)。
### 交换步骤（要完成这个只要得到x*y之后乘x两次逆元即可）
注意，在步骤 5 中，服务器 \( S \) 需要计算 \( \frac{x_i}{x_i - x_j} \)，其中 \( x_j \) 是 \( P_j \)生成的秘密值，\( P_i \) 不知道这个值。我们将使用一个子例程来解决这个问题。该子例程利用了以下事实：如果我们能够安全地计算 \( x^{-1}_k \cdot x_{k+1} \) 的乘积，则可以安全地计算 \( \frac{x_i}{x_i - x_j} \)，因为：

\[
\frac{x_i}{x_i - x_j} = \left( \frac{x_i - x_j}{x_i} \right)^{-1} = \left( 1 - \frac{x_j}{x_i} \right)^{-1} = \left( 1 - x^{-1}_i \cdot x_j \right)^{-1}
\]

而且，如果 \( j > i \)，则有：

\[
\frac{x_j}{x_i} = \prod_{k=i}^{j-1} \frac{x_{k+1}}{x_k}
\]