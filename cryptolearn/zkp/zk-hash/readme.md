# 简介
- 写在前面，真实协议要求随机数确认（就是防止攻击，但是这个过程和zkp关系不大，所以我就没有在代码实现里面去写了，实际上用基础rsa也行，但是感觉和zkp关系不大）
- 选自 https://eprint.iacr.org/2023/1879.pdf
## 哪些地方的暴露会导致协议丧失零知识性(安全分析)
1. **服务器的信任问题**：
  注意，在协议的两个版本中，如果服务器被破坏，它可以对哈希值进行暴力破解。实际上，如果 \( P_i \) 在第一次运行中是数据所有者，那么服务器 \( S \) 将学习到所有 \( j \in P \setminus \{P_i\} \) 的 \( h(x_j, y_j) \)（或在阈值协议中已知 \( (s_0, t_0) \)）。如果 \( P_u \neq P_i \) 在第二次运行中是数据所有者，那么 \( S \) 也会学习到 \( h(x_i, y_j) \)（或在阈值协议中学习到 \( h(f(x_i), g(x_i)) \)）。我们可以通过让参与者使用某种组密钥交换协议达成一致，选择一个随机数 \( R \)，并在消息 \( R \cdot m \) 而不是 \( m \) 上运行协议，从而防止这种情况的发生。除了 \( S \) 之外的其他参与者无法执行此攻击，因为每条消息都是通过安全通道发送的。
另外，如果 \( P_1 \) 发送 \( h(m_1 + x_1, m_2 + y_1) \)（或在阈值情况下发送 \( h(m_1 + f(x_1) \cdot \ell_1, m_2 + g(x_1) \cdot \ell_1) \)，其中 \( (m_1, m_2) \in GF(p)^2 \），则可以将明文空间的大小加倍。
2. **随机数生成的不安全性**：
   - 如果生成的随机数（如 \( r_i \)）不够随机或被预测，攻击者可能会利用这些信息来恢复参与者的秘密值，从而导致数据泄露。

3. **参与者之间的协作问题**：
   - 如果参与者之间没有有效的沟通机制，或者在协议执行过程中有任意参与者未按要求执行，可能会导致不一致的状态，从而使得某些秘密信息被间接泄露。

4. **重放攻击**：
   - 如果没有适当的消息认证机制，攻击者可能会重放先前的有效消息，试图诱导服务器或其他参与者相信某些操作是有效的，从而可能导致信息泄露。

5. **对安全通道的依赖**：
   - 协议假设所有消息都是在安全通道中传输的。如果传输通道被攻击，攻击者可能会截获或篡改消息，导致秘密信息的泄露。

6. **参与者的秘密值管理不当**：
   - 每个参与者都有其秘密值。如果参与者的秘密值管理不当（例如，泄露给不可信的第三方），可能会导致整个协议的安全性受到威胁。

7. **参数选择不当**：
   - 使用的曲线或参数如果选择不当，可能会导致基础密码学假设的破裂，从而使得协议中的哈希函数不再安全，攻击者可能会找到碰撞或逆向哈希。

以上这些情况都可能导致协议的安全性受损，进而影响到零知识证明的有效性。因此，确保每个环节的安全性和参与者的信任是至关重要的。
## 协议步骤
1. **协议设置**
   - 确定参与者集合 $P$ 和可信的服务器 $S$。
   - 选择合适的哈希函数 $h$ 和加密方案（如同态加密）。

2. **秘密生成**
   - 服务器 $S$ 随机生成两个秘密 $s_0$ 和 $t_0$。
   - 使用 Shamir 的秘密共享方案，将 $s_0$ 和 $t_0$ 分发给参与者。

3. **消息哈希计算（特定的哈希函数）**
   - 假设数据拥有者 $P_1$ 希望证明消息 $m$ 的有效性。
   - 数据拥有者通过计算 $h(m + f(x_1) \cdot \ell_1, g(x_1) \cdot \ell_1)$ 来生成哈希值 $h_1$。

4. **参与者的计算**
   - 所有参与者 $P_i$ 计算哈希值 $h_i$：
     $$
     h_i = h(f(x_i) \cdot \ell_i, g(x_i) \cdot \ell_i)
     $$
   - 将哈希值 $h_i$ 和加密的随机值 $\text{Enc}_{K_{pub}^S}(r_i)$ 发送给服务器 $S$。

5. **服务器的验证**
   - 服务器 $S$ 验证收到的哈希值是否一致，确保计算的有效性。

6. **零知识性质**
   - 参与者通过提供哈希值和加密的随机数，证明对有效信息的知识，而不泄露具体内容。

7. **随机数的使用**
   - 引入随机数 $R$ 在哈希计算中使用，增强安全性。