**下面主要针对如何证明一个计算的正确性**
计算的核心由以下基本运算组成：
- 左操作数
- 运算操作符
- 右操作数
- 输出
这种形式可以表示为：

左操作数 运算操作 符右操作数 = 输出

例如，操作数为 2 和 3，运算符为乘法，则有 $2 \times 3 = 6$。复杂计算由一系列这样的基本运算组成，因此了解单个运算在多项式中的表示至关重要。

### 验证计算可行性基石

考虑两个多项式 $f(x)$ 和 $g(x)$，它们相乘得 $h(x) = f(x) \times g(x)$，在任意 $x = r$ 处，$h(x)$ 的计算结果为 $f(r)$ 和 $g(r)$ 的乘积。例如，设 $f(x) = 2x^2 - 9x + 10$ 和 $g(x) = -4x^2 + 15x - 9$，当 $x = 1$ 时：
- $f(1) = 2 - 9 + 10 = 3$
- $g(1) = -4 + 15 - 9 = 2$
因此，$h(1) = f(1) \times g(1) = 3 \times 2 = 6$。这一性质适用于其他 $x$ 的值。如果我们将 $f(x)$ 和 $g(x)$ 相加，在 $x = 1$ 处的结果为 5。其他 $x$ 值的结果同样是两多项式值的和。如果我们将操作数的值表示为多项式，我们可以利用算术属性得到操作数的计算结果。
**总结一下这一部分什么意思**：就是如果一个多项式的运算能够行得通，那么带入任意一个值也是行得通的，并且由于上一部分（在验证多项式那一部分）任意一个点都能代表一条曲线特征的一部分，所以可以验证是否是某条曲线。
### 最初验证

当 prover 声称两个数字的乘积时，verifier 需验证输出的正确性。运算可表示为：

$$ l(x) \text{ 运算符 } r(x) = o(x) $$

在取值 $a$ 处，如果 $l(a) \text{ operator } r(a) = o(a)$ 成立，则：

$$ l(a) \text{ operator } r(a) - o(a) = 0 $$

这表明多项式 $l(x) \text{ operator } r(x) - o(x)$ 在 $x = a$ 处有根 $(x-a)$，即目标多项式 $t(x) = x - a$。ok啊，那我如果要证明$x=a_1,a_2,a_3...$的时候运算成立，只要把t(x)换成$(x-a_1)(x-a_2)...$的形式就行了
### 最初证明--单一计算证明

我们需要修改协议以支持单个乘法计算的证明。回到多项式 SNARK，我们已能证明多项式 $p(x)$ 的知识，但现在需要计算的是 $l(x)$, $r(x)$, $o(x)$。可定义 $p(x) = l(x) \times r(x) - o(x)$，但有两个问题：
- 证明阶段不能在加密值中执行乘法（$l(s) \times r(s)$），因配对仅能用一次，需用于验证多项式约束。
- Prover 可通过改变多项式结构保留有效因式 $t(x)$，如令 $p(x) = l(x)$ 或 $p(x) = l(x) - r(x)$ 等，但这会改变证明内容。

因此，prover 需分别提供 $l(s)$, $r(s)$, $o(s)$ 的证明，修改协议以证明多项式的知识。Verifier 在加密空间中验证 $l(s) \times r(s) - o(s) = t(s)h(s)$，使用配对来执行乘法并进行验证。协议更新如下：

**证明：**

- 分配系数给 $l(x)$, $r(x)$, $o(x)$，计算多项式 $h(x) = l(x) \times r(x) - o(x)$。
- 使用加密多项式 $g_{l(s)}$, $g_{r(s)}$, $g_{o(s)}$, $g_{h(s)}$。

**验证：**

- 定义证明 $p_i = (g_{l}, g_{r}, g_{o}, g_{h}, g_{l'}, g_{r'}, g_{o'})$。
- 检查多项式约束和运算有效性，如：$e(g_l, g_r) = e(g_{t(s)}, g_h) \cdot e(g_o, g)$。

此协议能证明乘法结果的正确性，简化了协议变换。后续会重新引入零知识。

### 证明升级--多个运算
现在我们已经能够证明单个算术运算了，但是要怎么扩展到多个运算上呢（这是我们的最终目标）？我们来尝试一下增加一个基本运算。想一想计算 _a_ × _b_ × _c_ 乘积的需求，在元素操作模型中，这代表着两个操作：

_a × b = r1_

_r1 × c = r2_

前面的讨论中我们通过对运算符多项式在任意取值 x 处 ，例如1，计算一个对应值，来表示一个操作数或者结果。有了这个性质的多项式并不会约束我们在不同 x 取值处用多项式来表示其他值。如示例中的 2，即：
![[Pasted image 20240922161132.png]]

这种独立性允许我们一次同时_执行_ 两个运算并且又不会把这两者搞乱，即相互之间不会妨碍。这个多项式算术的结果就变成了：

![[Pasted image 20240922161141.png]]

可以看出这个多项式有两个根 _x_=1 和 _x_=2。因而也就是两次计算都被正确执行了。我们再来看一个有三个乘法运算的例子 2 × 1 × 3 × 2，它按照下面的步骤执行：

_2 × 1 = 2_
_2 × 3 = 6_
_6 × 2 = 12_

我们要把它们表示为操作数多项式，对于由 _x_ _∈ {1_, _2_, _3_} 所表示的计算， _l_(_x_) 相应的要等于 2，2 和 6。即通过点 (_1_, _2)_, _(2_, _2)_, _(3_, _6_)，同样的 _r_(_x_) ∋ (_1_, _1)_,_(2_, _3)_,_(3_,_2_) ，_o_(_x_) ∋ (_1_, _2)_, _(2_, _6)_, _(3_, _12_)。

但是，我们要怎么找到经过这些点的多项式呢？对于任何包含超过一个点的例子，就必须要使用特定的数学方法了。

#### 多项式插值

为了构造_操作数_ 和 _输出多项式_，我们需要一种方法来用给定的一组点去构造一个能经过所有这些点的_弯曲_ 多项式，这叫_插值_。有几种不同的方法可以算出这个多项式：

- 一组未知方程
- 牛顿多项式
- 内维尔算法
- 拉格朗日多项式
- 快速傅里叶变换

这里使用第一个方法（实际上只能使用第一个）。我们令左运算多项式在每个点处与多项式结果值相等，然后对每个系数用其它术语表示出来再计算等式：

![[Pasted image 20240922161251.png]]

因而 _左操作数多项式_ 就是：

$l(x)= 2x^2-6x+6$

它和下面的图对应：

![](https://secbit.io/blog/2020/01/08/learn-zk-snark-from-zero-part-three/img/3/1*hAFtc6UZWhr34FA-ljVJ8w.png)

我们用相同的方式再计算 _r_(_x_) 和 _o_(_x_)：

$$r(x) = \frac{-3x^2 + 13x - 8}{2}; \quad o(x) = x^2 + x$$
**小结一下这一小章，如何使用多项式快速得到通过特定点的曲线，并且使用这个来表示l(x)和r(x)（解n+1元方程组即可），并且通过得到的l(x) * r(x)-o(x)的形式除以特定的t(x)来检验证明者是否正确的进行了计算**
**当前协议存在一些缺陷，无法有效证明 prover 拥有多项式 $l(x)$、$r(x)$ 和 $o(x)$，以及它们在 $t(x)$ 的根处满足 $l(x) \cdot r(x) = o(x)$。具体问题包括：**
1) **多个计算关系分开表示，无法约束它们之间的关系。**
2) **Prover 生成的证明仅包含计算结果，左操作数和右操作数混用，难以被识别。**
3) **左操作数、右操作数和输出分开表示，导致它们之间的关系无法约束。**
所以证明者还是存在着一些作弊的自由度，导致协议完备性的缺失，接下来，约束！
### 约束单个变量的操作数多项式

我们来看一个简单的例子，其中左操作符多项式 $l(x)$ 只包含一个变量 $a$。为确保 $l(x)$ 在每个运算中 $a$ 相同，prover 可以任意控制 $x$ 的每个次幂的系数。
1 * 2=2
1 * 3=3
1 * 5=5
1 * 26=26

考虑两个多项式，它们在 $x=1$ 和 $x=2$ 处分别取值 1 和 2。
![[Pasted image 20240922163408.png]]
第二个多项式的系数是第一个的两倍。由于多项式的算术性质，若想同时改变多项式中所有值，则必须改变它的比例。因此，如果 verifier 要求 prover 在所有计算中使用相同的值，就需要限制 prover 只能修改比例，而不是单个系数。为保持系数比例不变，verifier 可以限制 prover 只使用提供的秘密值 $s$ 的幂。这样，verifier 可以限制完整的多项式，而不仅是单独的加密值。

#### 协议过程

1. **Setup**
   - 使用对应系数构造操作符多项式 $l(x)$。
   - 选择随机数 $\alpha$ 和 $s$。
   - 生成加密的 $l(s)$ 和其转换 $(g_l(s), g_\alpha l(s))$ 设置证明密钥。
   - 设置验证密钥 $g_\alpha$。

2. **Proving**
   - 对操作数值 $v$，乘以操作数多项式 $g_l(s) v$。
   - 提供操作数多项式的乘法证明 $(g_{vl}(s), g_{v\alpha l}(s))$。

3. **Verification**
   - 解析证明为 $(g_l, g_l')$。
   - 验证比例：$e(g_l', g) = e(g_l, g_\alpha)$。

由于 prover 需要返回相同的 $\alpha$ 转换关系，因此他无法修改 $l(x)$ 的单个系数。例如，如果多项式为 $l(x) = ax^2 + bx + c$，prover 只能用一个值 $v$ 去修改整个多项式。因为配对使其不能与另一个多项式做乘法，所以 prover 也无法提供 $s$ 的单个求幂值的 $\alpha$ 变换。Prover 不能进行加法或减法，因为这需要未加密的 $\alpha$ 知识。
**这个地方约束了l(x)相等的情况，正如标题所说**
### 约数多变量操作多项式

操作数多项式 $l(x)$ 可以分为变量多项式 $l_a(x)$ 和 $l_d(x)$，
![[Pasted image 20240922165238.png]]

如果某个变量在特定运算中作为操作数，则该变量多项式的值为 $1$，否则为 $0$。由于 $0$ 乘以任何数结果为 $0$，我们可以在相加时忽略这些项。例如，在我们的例子中，变量多项式需要满足以下条件：

$$
l_a(1) = 1, \ l_a(2) = 1, \ l_a(3) = 0
$$

$$
l_d(1) = 0, \ l_d(2) = 0, \ l_d(3) = 1
$$
![[Pasted image 20240922165535.png]]
这样我们就可以对不同的变量分别赋值，并将它们加在一起计算操作数多项式。

$$
l_d(1) = 0, \ l_d(2) = 0, \ l_d(3) = 1
$$

通过这种方式，我们可以为每个变量单独赋值，然后将它们加在一起计算出操作数多项式。例如当 $a = 3$ 和 $d = 2$ 时：

$$
L(x) = a \cdot l_a(x) + d \cdot l_d(x)
$$

#### Setup 过程

1. 构造 $l_a(x)$ 和 $l_b(x)$，使它们在相应的计算点上为 $1$，其他点为 $0$。
2. 选择随机数 $s$ 和 $\alpha$。
3. 计算并加密未赋值的变量多项式：

   $$ g_{l_a}(s), g_{l_d}(s) $$

4. 计算这些多项式的变换结果：

   $$ g_{\alpha l_a}(s), g_{\alpha l_d}(s) $$

5. 设置证明密钥：

   $$ (g_{l_a}(s), g_{l_d}(s), g_{\alpha l_a}(s), g_{\alpha l_d}(s)) $$

6. 设置验证密钥：

   $$ g_{\alpha} $$

#### Proving 过程

1. 为变量多项式赋值 $a$ 和 $d$：

   $$ (g_{l_a}(s))^a, (g_{l_d}(s))^d $$

2. 对变换后的变量多项式进行相同的赋值：

   $$ (g_{\alpha l_a}(s))^a, (g_{\alpha l_d}(s))^d $$

3. 将所有赋值后的变量多项式相加，形成操作数多项式的形式：

   $$ g_L(s) = g_{al_a}(s) \cdot g_{dl_d}(s) $$

#### Verification 过程

解析证明为 $(g_L, g_L')$，验证提供的多项式是否为原始变量多项式的和：

$$
e(g_L', g) = e(g_L, g_{\alpha})
$$

即验证：

$$
\alpha \cdot (a \cdot l_a(s) + d \cdot l_d(s)) = \alpha \cdot L(s)
$$

由于 prover 拿到的只是这些多项式的加密值，并且 $\alpha$ 的变换值会参与验证，prover 无法修改变量多项式的系数，也无法通过多项式相加或乘以另一个多项式来作弊。

### 小结
这一部分只是关于如何验证一个计算的正确的完备性做好了正确的构建，关于其零知识性并未涉及，但其实我觉得应该是最后一段这部分可以做出一些改变来增加零知识性